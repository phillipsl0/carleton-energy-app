import buildingsDetail from './BuildingsDetail';
// import news from './SustainabilityNews';
import events from './SustainabilityEvents';


// 1) For a given building, resource and timeframe, return (from API) 
//      a single value (e.g. gal/week in Burton)
// 2) Energy the windmill generated within a specified timeframe
// 3) Energy generated by solar panels within a specified timeframe
// 4) (eventually) Data over time to generate graphs


/* Naming Convention:
 * getTotal: Returns one number which is the total sum
 * getOverTime: Returns a table with the numbers divided up based on a given time scale
 *
 * Order of variables:
 * building, utility, timeStart, timeEnd, timeScale
 */


export function getBuildingsList() {
    // return list of every building name with data (e.g. "Burton", "Sayles", etc.)
    // /api/buildings/names

    var buildings = ["Burton", "Sayles", "Severance", "Davis", "Musser", "Myers", "Cassat",
                        "Memo", "Nourse", "Evans", "Goodhue", "Watson", "Scoville"];

    return buildings;
}

export function getBuildingsDetail() {
    return buildingsDetail;
}

export function getUtilitiesList() {
    var utilities = ["electricity", "water"];

    return utilities;
}

export function getUnitsList() {
    var units = {"electricity": "kWh", "water": "gal"}

    return units;
}

export function getSustainabilityNews() {
    // https://apps.carleton.edu/sustainability/feeds/blogs/sustaining_carleton
    // https://api.rss2json.com/v1/api.json?
    //      rss_url=https%3A%2F%2Fapps.carleton.edu%2Fsustainability%2Ffeeds%2Fblogs%2Fsustaining_carleton
    return news;
}

export function getSustainabilityEvents() {
    // https://apps.carleton.edu/sustainability/feeds/events
    // https://api.rss2json.com/v1/api.json?
    //      rss_url=https%3A%2F%2Fapps.carleton.edu%2Fsustainability%2Ffeeds%2Fevents
    return events;
}


// -------------------- Electricity Generation -------------------------

// timeStart, timeEnd are Date objects. 
// timeScale is the resolution of the data in minutes (e.g. 1 minute vs 15 minute increments)
export function getEnergyGenerationOverTime(timeStart, timeEnd, timeScale) {
    var scaleFactorWind = 400;
    var scaleFactorSolar = 2; 

    var numberEntries = Math.round(Math.abs(timeEnd - timeStart) / (60000 * timeScale));
    var currentTime = new Date(timeEnd);

    var table = new Array(numberEntries);
    for (var i = numberEntries-1; i >= 0; i--) {
        table[i] = {};
        table[i]["date"] = currentTime.toString();
        table[i]["wind"] = Math.random() * scaleFactorWind * timeframe;
        table[i]["solar"] = Math.random() * scaleFactorSolar * timeframe;
        table[i]["total"] = table[i]["wind"] + table[i]["solar"];

        currentTime.setMinutes(currentTime.getMinutes() - timeScale);
    }

    return table;
}

export function getWindGenerationOverTime(timeStart, timeEnd, timeScale) {
    var totals = getEnergyGenerationOverTime(timeStart, timeEnd, timeScale);
    var table = [];
    for (var i = 0; i < totals.length; i++) {
        table[i] = {};
        table[i]["date"] = totals[i]["date"];
        table[i]["wind"] = totals[i]["wind"];
    }

    return table;
}

export function getSolarGenerationOverTime(timeStart, timeEnd, timeScale) {
    var totals = getEnergyGenerationOverTime(timeStart, timeEnd, timeScale);
    var table = [];
    for (var i = 0; i < totals.length; i++) {
        table[i] = {};
        table[i]["date"] = totals[i]["date"];
        table[i]["solar"] = totals[i]["solar"];
    }

    return table;
}

export function getTotalGenerationOverTime(timeStart, timeEnd, timeScale) {
    var totals = getEnergyGenerationOverTime(timeStart, timeEnd, timeScale);
    var table = [];
    for (var i = 0; i < totals.length; i++) {
        table[i] = {};
        table[i]["date"] = totals[i]["date"];
        table[i]["total"] = totals[i]["total"];
    }

    return table;
}


export function getEnergyGeneration(timeStart, timeEnd) {
    // return value of how much electricity we are generating from wind/solar, etc
    // /api/generation

    // return map with one entry for "wind", one for "solar", and one for "total"

    var scaleFactorWind = 400;
    var scaleFactorSolar = 2; 

    // calculate number of 15-min chunks b/w 'timeStart' and 'timeEnd'
    var timeframe = Math.abs(timeEnd - timeStart) / (60000 * 15); // 60,000ms per min * 15min

    var table = [];
    table["wind"] = Math.random() * scaleFactorWind * timeframe;
    table["solar"] = Math.random() * scaleFactorSolar * timeframe;
    table["total"] = table["wind"] + table["solar"];

    return table;
}

export function getTotalWindGeneration(timeStart, timeEnd) {
    return getEnergyGeneration(timeStart, timeEnd)["wind"];
}

export function getTotalSolarGeneration(timeStart, timeEnd) {
    return getEnergyGeneration(timeStart, timeEnd)["solar"];
}

export function getTotalEnergyGeneration(timeStart, timeEnd) {
    return getEnergyGeneration(timeStart, timeEnd)["total"];
}

export function getCurrentWindGeneration() {
    var timeStart = new Date();
    timeStart.setMinutes(timeStart.getMinutes() - 15);
    var timeEnd = new Date();

    return getTotalWindGeneration(timeStart, timeEnd);
}

export function getCurrentSolarGeneration() {
    var timeStart = new Date();
    timeStart.setMinutes(timeStart.getMinutes() - 15);
    var timeEnd = new Date();

    return getTotalSolarGeneration(timeStart, timeEnd);
}

export function getCurrentEnergyGeneration() {
    var timeStart = new Date();
    timeStart.setMinutes(timeStart.getMinutes() - 15);
    var timeEnd = new Date();

    return getTotalEnergyGeneration(timeStart, timeEnd);
}

// added function to get usage I need
export function getCurrentGenerationGraphFormat() {
    var totalSolar = getCurrentSolarGeneration();
    var totalWind = getCurrentWindGeneration();

    var data = new Array(3);

    data[0] = {'x': 'Solar', 'y': totalSolar};
    data[1] = {'x': 'Wind', 'y': totalWind};
    data[2] = {'x': 'Total', 'y': totalSolar+totalWind};

    return data;
}

export function getTotalGenerationGraphFormat(timeStart, timeEnd, timeScale) {
    var waterTable = getCampusUtilityConsumptionOverTime("water", timeStart, timeEnd, timeScale);
    var electricityTable = getCampusUtilityConsumptionOverTime("electricity", timeStart, timeEnd, timeScale);
    var combinedTable = new Array(waterTable.length);
    var finalTable = {};
    var currData = 0;
    var rank = waterTable.length;

    for (var i=waterTable.length-1; i >= 0; i--) {
        combinedTable[i] = {};
        combinedTable[i]["x"] = waterTable[i]["date"];
        combinedTable[i]["y"] = (waterTable[i]["water"] + electricityTable[i]["electricity"])/1000;

        if (i==waterTable.length-1) {
            currData = combinedTable[i]["y"];
        } else if (combinedTable[i]["y"] > currData) {
            rank-=1;
        }
    }

    finalTable["rank"] = rank;
    finalTable["data"] = combinedTable;

    return finalTable;
}

// -------------------- Utility Consumption -------------------------

export function getBuildingUtilityConsumptionOverTime(building, utility, timeStart, timeEnd, timeScale) {

    // different utilities have different "typical" amounts
    var scaleFactor;

    if (utility == "water") {
        scaleFactor = 400;
    } else if (utility == "electricity") {
        scaleFactor = 12; 
    }

    var buildings = getBuildingsList();

    if (buildings.indexOf(building) % 2 == 0) {
        scaleFactor *= 2;
    }

    var numberEntries = Math.round(Math.abs(timeEnd - timeStart) / (60000 * timeScale));
    var currentTime = new Date(timeEnd);

    var table = new Array(numberEntries);
    for (var i = numberEntries-1; i >= 0; i--) {
        table[i] = {};
        table[i]["date"] = currentTime.toString();
        table[i][utility] = Math.random() * scaleFactor * timeframe;

        currentTime.setMinutes(currentTime.getMinutes() - timeScale);
    }

    return table;
}

export function getTotalBuildingUtilityConsumption(building, utility, timeStart, timeEnd) {
    /*
        parameter   | object type
        --------------------------
        'building'  | String 
        'utility'   | String (options for now: "electricity", "water")
        'timeStart' | Date
        'timeEnd'   | Date
    */

    // return value of how much of a resource we have consumed at one building over a time frame
    // /api/buildings/usage/{buildingName}/current?utility={resource}

    // Insert real API call here

    /* RETURN DUMMY DATA (below) */

    // different utilities have different "typical" amounts
    var scaleFactor = 2;

    if (utility == "water") {
        scaleFactor = 400;
    } else if (utility == "electricity") {
        scaleFactor = 12; 
    } 

    // calculate number of 15-min chunks b/w 'timeStart' and 'timeEnd'
    var timeframe = Math.abs(timeEnd - timeStart) / (60000 * 15); // 60,000ms per min * 15min

    var result = Math.random() * scaleFactor * timeframe;

    return result;

}

export function getCurrentBuildingUtilityConsumption(building, utility) {
    var timeStart = new Date();
    timeStart.setMinutes(timeStart.getMinutes() - 15);
    var timeEnd = new Date();

    return getTotalBuildingUtilityConsumption(building, utility, timeStart, timeEnd);
}

// added function to get usage I need
export function getCurrentConsumptionGraphFormat() {
    var totalWater = 0;
    var totalElectricity = 0;
    var data = new Array(3);
    var buildings = getBuildingsList();

    buildings.forEach(function(building) {
        totalWater += getCurrentBuildingUtilityConsumption(building, "water");
        totalElectricity += getCurrentBuildingUtilityConsumption(building, "electricity");
    });

    data[0] = {'x': 'Water', 'y': totalWater};
    data[1] = {'x': 'Electricity', 'y': totalElectricity};
    data[2] = {'x': 'Total', 'y': totalWater+totalElectricity};
//    data["Water"] = totalWater;
//    data["Electricity"] = totalElectricity;
//    data["Total"] = totalWater + totalElectricity;

    return data;
}

export function getCampusUtilityConsumptionOverTime(utility, timeStart, timeEnd, timeScale) {

    // different utilities have different "typical" amounts
    var scaleFactor;

    if (utility == "water") {
        scaleFactor = 1000;
    } else if (utility == "electricity") {
        scaleFactor = 120; 
    }

    var numberEntries = Math.round(Math.abs(timeEnd - timeStart) / (60000 * timeScale));
    var currentTime = new Date(timeEnd);

    var table = new Array(numberEntries);
    for (var i = numberEntries-1; i >= 0; i--) {
        table[i] = {};
        table[i]["date"] = currentTime.toString();
        table[i][utility] = Math.random() * scaleFactor * numberEntries;

        currentTime.setMinutes(currentTime.getMinutes() - timeScale);
    }

    return table;
}

// Added wrapper to get data the way I need it
export function getTotalConsumptionGraphFormat(timeStart, timeEnd, timeScale) {
    var waterTable = getCampusUtilityConsumptionOverTime("water", timeStart, timeEnd, timeScale);
    var electricityTable = getCampusUtilityConsumptionOverTime("electricity", timeStart, timeEnd, timeScale);
    var combinedTable = new Array(waterTable.length);
    var finalTable = {};
    var currData = 0;
    var rank = waterTable.length;

    for (var i=waterTable.length-1; i >= 0; i--) {
        combinedTable[i] = {};
        combinedTable[i]["x"] = waterTable[i]["date"];
        combinedTable[i]["y"] = (waterTable[i]["water"] + electricityTable[i]["electricity"])/1000;

        if (i==waterTable.length-1) {
            currData = combinedTable[i]["y"];
        } else if (combinedTable[i]["y"] > currData) {
            rank-=1;
        }
    }

    finalTable["rank"] = rank;
    finalTable["data"] = combinedTable;

    return finalTable;
}

export function getTotalCampusUtilityConsumption(utility, timeStart, timeEnd) {
    // return total campus consumption of utitlity over specified time frame

    // different utilities have different "typical" amounts
    var scaleFactor;

    if (utility == "water") {
        scaleFactor = 1000;
    } else if (utility == "electricity") {
        scaleFactor = 120; 
    } 

    // calculate number of 15-min chunks b/w 'timeStart' and 'timeEnd'
    var timeframe = Math.abs(timeEnd - timeStart) / (60000 * 15); // 60,000ms per min * 15min

    return Math.random() * scaleFactor * timeframe; 
}

export function getCurrentCampusUtilityConsumption(utility) {
    var timeStart = new Date();
    timeStart.setMinutes(timeStart.getMinutes() - 15);
    var timeEnd = new Date();

    return getTotalCampusUtilityConsumption(utility, building, timeStart, timeEnd);
}

export function getEveryBuildingUtilityConsumption(utility) {
    var scaleFactor;

    if (utility == "water") {
        scaleFactor = 400;
    } else if (utility == "electricity") {
        scaleFactor = 12; 
    }

    var buildings = getBuildingsList();

    var total = 0;
    var table = new Array(buildings.length);
    for (var i = 0; i < table.length; i++) {
        table[i] = {};
        table[i]["building"] = buildings[i];
        table[i][utility] = Math.random() * scaleFactor;
        total += table[i][utility];
    }

    for (var i = 0; i < table.length; i++) {
        table[i]["percent"] = table[i][utility] / total;
    }

    table = sortByKey(table, "percent");

    return table;
}

// Helper function to sory the building list (in descending order)
export function sortByKey(array, key) {
    return array.sort(function(a, b) {
        var x = a[key]; 
        var y = b[key];
        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
    });
}

